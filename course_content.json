{
  "variables": {
    "title": "Variables: The Containers of Code",
    "body": "A variable is a name given to a memory location. Think of it as a label or a box that holds a value. Python is dynamically typed, meaning you don't declare the type, but the value you store defines it.\n\n### Data Types\n\n| Type | Description | Example |\n| :--- | :--- | :--- |\n| **str** | Text (String) | `\\\"Alex\\\"` |\n| **int** | Whole numbers (Integer) | `16` |\n| **float** | Decimal numbers | `98.5` |\n| **bool** | True or False (Boolean) | `True` |\n| **NoneType** | Represents the absence of a value | `None` |\n\n```python\nplayer_name = \\\"Alex\\\"          # String\nplayer_age = 16               # Integer\nplayer_health = 98.5            # Float\nis_alive = True                 # Boolean\nspecial_power = None            # NoneType\n```\n\n---\n\n### Type Checking & Conversion\n\nInput from users is always a string! You must convert it using `int()`, `float()`, or `str()`.\n\n```python\nprint(\\\"Type of player_age:\\\", type(player_age))\nprint(\\\"Is health a float?\\\", isinstance(player_health, float))\n\n# Converting types\nage_input = input(\\\"Enter your age: \\\")  # always returns string!\nage = int(age_input)                    # convert to int\nprint(\\\"Next year you'll be:\\\", age + 1)\n```\n\n### Pythonic Tricks\n\nPython allows simple **multiple assignment** and **variable swapping**.\n\n```python\nx, y, z = 10, 20, 30\nprint(x, y, z)\n\n# Swap values in one line\na, b = 5, 10\na, b = b, a\nprint(f\\\"After swap → a={a}, b={b}\\\")\n```\n\n> **Note on Constants:** By convention, constant variables are named using **ALL CAPS** (e.g., `MAX_LIVES = 3`).\n\n### Mathematical Operators and Precedence\n\nPython follows standard mathematical order: **Parentheses, Exponents, Multiplication/Division, Addition/Subtraction** (PEMDAS).\n\n| Operator | Name | Example | Result |\n| :--- | :--- | :--- | :--- |\n| `+` | Addition | `5 + 2` | `7` |\n| `-` | Subtraction | `5 - 2` | `3` |\n| `*` | Multiplication | `5 * 2` | `10` |\n| `/` | Division (Float) | `5 / 2` | `2.5` |\n| `//` | Floor Division (Integer) | `5 // 2` | `2` |\n| `%` | Modulo (Remainder) | `5 % 2` | `1` |\n| `**` | Exponentiation | `5 ** 2` | `25` |\n\n**Precedence Example:** `2 + 3 * 4` equals 14 (multiplication happens first). Use parentheses `()` to enforce order: `(2 + 3) * 4` equals 20.\n\n```python\nx = 10\nx += 5  # x is now 15 (Shorthand for x = x + 5)\ny = 10\ny //= 3 # y is now 3 (Floor division)\n\nresult = 10 * 2 + 8 / 4\nprint(f\\\"Result (10 * 2 + 8 / 4): {result}\\\") # Output: 22.0\n```\n"
  },
  "conditionals": {
        "title": "2. CONDITIONAL LOGIC: Controlling the Flow",
        "body": "Conditional statements are the backbone of decision-making in any program. They allow your code to execute different blocks based on whether a condition is true or false.\n\n### Basic If-Elif-Else Structure\n\nThe `if` statement checks the first condition. If true, that block runs, and the rest is skipped. `elif` (else if) checks subsequent conditions, and `else` runs only if all previous conditions were false.\n\n```python\nage = 17\n\nif age >= 18:\n    age_group = \"Adult\"\nelif age >= 13:\n    age_group = \"Teenager\"\nelse:\n    age_group = \"Child\"\nprint(f\"You are a {age_group}\")\n```\n\n---\n\n### Nested Conditions\n\nWhen one decision depends on the outcome of another, you can **nest** `if` statements. This is common for complex logic (e.g., checking weather, then checking if you have the right gear).\n\n```python\nweather = \"rainy\"\nhas_umbrella = True\n\nif weather == \"rainy\":\n    if has_umbrella:\n        print(\"You can go out – you have an umbrella!\")\n    else:\n        print(\"Stay home – no umbrella!\")\nelse:\n    print(\"Perfect weather – go enjoy!\")\n```\n\n---\n\n### Logical Operators: `and`, `or`, `not`\n\nUse these to combine or negate conditions.\n\n- **`and`:** Both conditions must be `True`.\n- **`or`:** At least one condition must be `True`.\n- **`not`:** Reverses the truth value (True becomes False, False becomes True).\n\n```python\nis_weekend = True\ntime = 10\n\n# 'or' example: Can play if it's the weekend OR (it's after 6PM OR before 10AM)\ncan_play_games = is_weekend or (time >= 18 or time <= 10)\nprint(\"Can play games now? →\", can_play_games)\n\nis_logged_in = True\nis_banned = False\n\n# 'and' and 'not' example\nif is_logged_in and not is_banned:\n    print(\"Access granted.\")\nelse:\n    print(\"Access denied.\")\n```\n\n---\n\n### Python Magic: Chained Comparisons & Ternary Operator\n\n#### 1. Chained Comparisons\n\nPython allows you to check if a value falls between two boundaries in a single, readable line.\n\n```python\nage = 17\n\n# Check if age is greater than or equal to 13 AND less than or equal to 19\nif 13 <= age <= 19:\n    print(\"You are officially a teenager!\")\n```\n\n#### 2. Ternary Operator (One-Liner If-Else)\n\nUse this for simple conditional assignments to keep your code concise.\n\n`[value_if_true] if [condition] else [value_if_false]`\n\n```python\nage = 22\nstatus = \"Adult\" if age >= 18 else \"Minor\"\nprint(\"Legal status:\", status) # Output: Adult\n\nusername = \"\"\nmessage = \"Welcome back!\" if username else \"Please log in\"\nprint(message) # Output: Please log in\n```\n\n---\n\n### Membership Testing with `in`\n\nUse the `in` operator to check if a value exists within a list, tuple, or string.\n\n```python\nusername = \"bob\"\nallowed_users = [\"alice\", \"bob\", \"charlie\"]\n\nif username.lower() in allowed_users:\n    print(\"Welcome, authorized user!\")\nelse:\n    print(\"Unauthorized user!\")\n```"
    },
    "loops": {
        "title": "3. LOOPS IN PYTHON: Repetitive Actions",
        "body": "Loops are fundamental for performing repetitive tasks without writing the same code block multiple times. Python primarily uses two types of loops: `for` and `while`.\n\n### 1. FOR Loop: Iterating Over Sequences\n\nThe `for` loop is typically used when you know the number of iterations or are looping over a finite sequence (like a list, tuple, or string). It uses the built-in `range()` function for counting.\n\n#### The `range()` function:\n\n- `range(stop)`: Counts from 0 up to (but not including) `stop`.\n- `range(start, stop)`: Counts from `start` up to `stop`.\n- `range(start, stop, step)`: Counts with a specified increment.\n\n```python\n# Counting from 0 to 4:\nfor i in range(5):\n \tprint(i) # 0, 1, 2, 3, 4\n\n# With step (every 2nd number):\nprint(\"Even numbers 2 to 10:\")\nfor n in range(2, 11, 2):\n \tprint(n) # 2, 4, 6, 8, 10\n```\n\n#### Looping Over Collections\n\n```python\n# Looping over a string\nword = \"Python\"\nfor letter in word:\n \tprint(letter)\n\n# Looping over a list with index + value using enumerate()\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor index, fruit in enumerate(fruits, start=1):\n \tprint(f\"{index}. {fruit}\")\n```\n\n---\n\n### 2. WHILE Loop: Repeating Until a Condition is Met\n\nThe `while` loop is used when the number of iterations is unknown, and the loop continues as long as a specified condition remains `True`.\n\n```python\nprint(\"Countdown from 5:\")\ncount = 5\nwhile count > 0:\n \tprint(count)\n \tcount -= 1 # Crucial step to prevent infinite loop!\nprint(\"Blast off!\")\n```\n\n> **WARNING:** Always ensure the condition eventually becomes `False` to avoid an **infinite loop**!\n\n---\n\n### 3. LOOP CONTROL: `break`, `continue`, and `else`\n\nThese keywords allow fine-grained control over loop execution.\n\n- **`break`:** Stops the loop entirely and immediately moves to the code following the loop body.\n- **`continue`:** Skips the rest of the current iteration and moves to the next one.\n- **`else` (on a loop):** The code in the `else` block runs **only** if the loop completed normally (i.e., **no `break`** statement was executed).\n\n```python\nprint(\"Searching for number 7...\")\nfor num in range(1, 15):\n \tif num == 7:\n \t\tprint(\"Lucky 7 found!\")\n \t\tbreak  # Exit loop immediately\n \telif num % 2 == 0:\n \t\tcontinue # Skip even numbers\n \tprint(num) # Only prints odd numbers (except 7)\nelse:\n \tprint(\"7 not found\") # This line is NOT executed because of the 'break'\n```\n\n#### Infinite Loop Pattern\n\nIt is common to create a `while True` loop and use `break` to exit based on user input or an internal condition.\n\n```python\nwhile True:\n \tpassword = input(\"Enter password: \")\n \tif password == \"secret123\":\n \t\tprint(\"Access granted!\")\n \t\tbreak\n \telif password == \"quit\":\n \t\tbreak\n \telse:\n \t\tprint(\"Wrong password. Try again.\")\n```\n\n---"
    },
    
    "functions": {
        "title": "4. FUNCTIONS & RECURSION: Advanced Tools",
        "body": "Functions allow you to compartmentalize code, making programs modular, reusable, and easier to debug. Python functions are incredibly flexible.\n\n### 1. Function Arguments and Returns\n\n#### Default Parameters\n\nAssigning a value in the function definition makes the parameter optional. If the user doesn't provide it, the default value is used.\n\n```python\ndef greet(name=\"friend\", greeting=\"Hello\"):\n \treturn f\"{greeting}, {name}! Welcome to Python!\"\n\nprint(greet(\"Alex\"))      # Hello, Alex! (uses default greeting)\nprint(greet())            # Hello, friend! (uses both defaults)\n```\n\n#### Multiple Return Values\n\nPython functions can seamlessly return multiple values, which are automatically packaged as a **tuple** and can be easily **unpacked** by the caller.\n\n```python\ndef get_user_info():\n \treturn \"Alice\", 16, \"Canada\"\n\nname, age, country = get_user_info() # Unpacking!\nprint(f\"{name} is {age} years old from {country}\")\n```\n\n---\n\n### 2. Flexible Arguments: `*args` and `**kwargs`\n\nThese special syntaxes allow your function to accept a variable (unknown) number of arguments.\n\n| Syntax | Name | Type Received | Purpose |\n| :--- | :--- | :--- | :--- |\n| `*args` | Arbitrary positional arguments | **Tuple** | Collects all positional arguments not explicitly defined. |\n| `**kwargs` | Arbitrary keyword arguments | **Dictionary** | Collects all extra keyword (named) arguments. |\n\n```python\n# *args example (sums any number of inputs)\ndef sum_all(*numbers):\n \ttotal = 0\n \tfor n in numbers: total += n\n \treturn total\n\nprint(sum_all(1, 2, 3, 4, 5))\n\n# **kwargs example (creates profile from keywords)\ndef create_profile(**info):\n \treturn {\n \t\t\"name\": info.get(\"name\", \"Unknown\"),\n \t\t\"level\": info.get(\"level\", 1)\n \t}\n\nuser1 = create_profile(name=\"Bob\", level=42, premium=True)\nprint(user1)\n```\n\n---\n\n### 3. Scope: Local vs. Global\n\n**Scope** defines where a variable can be accessed. Variables defined inside a function are **local** and cannot be used outside of it. Variables defined outside are **global**.\n\n```python\nglobal_score = 100\n\ndef update_score(points):\n \tlocal_bonus = 50\n \ttotal = global_score + points + local_bonus\n \treturn total\n\nprint(update_score(20))\n# print(local_bonus) # This would cause a NameError!\n```\n\n---\n\n### 4. Recursion: Functions Calling Themselves\n\nRecursion is the process where a function calls itself, breaking a complex problem down into simpler, self-similar sub-problems. It requires two parts:\n\n1.  **Base Case:** The condition that stops the recursion (critical to prevent infinite loops).\n2.  **Recursive Step:** The part where the function calls itself with a simplified input.\n\n```python\ndef factorial(n):\n \tif n == 0 or n == 1: # Base case\n \t\treturn 1\n \treturn n * factorial(n - 1) # Recursive step\n\nprint(\"5! =\", factorial(5)) # Output: 120\n\n# Fibonacci using recursion\ndef fibonacci(n):\n \tif n <= 1:\n \t\treturn n # Base case\n \treturn fibonacci(n-1) + fibonacci(n-2)\n\nprint(\"Fibonacci 8:\", fibonacci(8))\n```\n [Image of recursive factorial function call stack] \n\n---\n\n### 5. Lambda Functions (Anonymous Functions)\n\nA **lambda function** is a small, anonymous function defined with a single expression. It cannot contain multiple statements or annotations, but is useful for short, inline operations, especially when passed as an argument to higher-order functions like `sorted()`, `map()`, or `filter()`.\n\n```python\nsquare = lambda x: x ** 2\nprint(square(5)) # 25\n\n# Using lambda to sort a list by remainder when divided by 3\nnumbers = [1, 5, 2, 8, 3]\nsorted_nums = sorted(numbers, key=lambda x: x % 3)\nprint(\"Sorted by remainder:\", sorted_nums)\n```\n\n---\n\n### 6. Function as a First-Class Citizen\n\nIn Python, functions are first-class objects, meaning they can be assigned to variables, stored in data structures, and passed as arguments to other functions, just like numbers or strings.\n\n```python\ndef shout(text):\n \treturn text.upper() + \"!!!\"\n\ndef whisper(text):\n \treturn text.lower() + \"...\"\n\ndef speak(func, message):\n \t# 'func' is the function passed as an argument\n \treturn func(message)\n\nprint(speak(shout, \"hello\"))  # HELLO!!!\nprint(speak(whisper, \"HELLO\")) # hello...\n```"
    },
  "oops": {
        "title": "5. OOP MASTERCLASS: Classes, Inheritance, and Encapsulation",
        "body": "Object-Oriented Programming (OOP) is a paradigm that structures programs around objects (instances of classes), rather than functions and logic. It helps manage complexity by modeling real-world entities. \n\n### 1. Basic Class Structure\n\nA **Class** is a blueprint. An **Object** (or instance) is a specific entity built from that blueprint. \n\n- **`__init__`**: The constructor method. It runs automatically when an object is created.\n- **Instance Variables**: Belong to a specific object (`self.name`).\n- **Class Variables**: Shared by ALL objects of that class (`Player.total_players`).\n\n```python\nclass Player:\n \ttotal_players = 0 # Class variable\n\n \tdef __init__(self, name, level=1, health=100):\n \t\tself.name = name       # Instance variable\n \t\tPlayer.total_players += 1\n\n \tdef level_up(self):\n \t\tself.level += 1\n\n# Create objects\np1 = Player(\"Alex\")\np2 = Player(\"Emma\")\nprint(f\"Total players: {Player.total_players}\")\n```\n\n---\n\n### 2. Encapsulation: Visibility\n\nEncapsulation bundles data (variables) and methods (functions) that operate on that data. Python uses naming conventions to suggest visibility:\n\n* **Public**: `self.name` (Access anywhere)\n* **Protected**: `self._score` (Convention: don't access directly)\n* **Private**: `self.__secret` (Name mangling makes it hard to access)\n\n---\n\n### 3. Inheritance: Reusing Code\n\n**Inheritance** allows a new class (**Child/Derived**) to acquire the properties and methods of an existing class (**Parent/Base**).\n\n#### Using `super()`\n\nThe `super()` function is used to call methods from the parent class, most commonly used inside the child's `__init__` method.\n\n```python\nclass Enemy:\n \tdef __init__(self, name, power):\n \t\tself.name = name\n\n \tdef attack(self):\n \t\treturn f\"{self.name} attacks!\"\n\nclass Boss(Enemy):\n \tdef __init__(self, name, power, special_move):\n \t\tsuper().__init__(name, power) # Calls Enemy.__init__\n \t\tself.special_move = special_move\n\n \tdef attack(self): # Method Overriding (changes parent behavior)\n \t\treturn f\"{self.name} uses {self.special_move}!\"\n\nboss = Boss(\"Dragon Lord\", 50, \"Fire Breath\")\nprint(boss.attack())\n```\n\n#### Multiple Inheritance\n\nA class can inherit from multiple parent classes, giving it capabilities from all of them.\n\n```python\nclass Flyer:\n \tdef fly(self):\n \t\treturn \"Flying high!\"\n\nclass Swimmer:\n \tdef swim(self):\n \t\treturn \"Swimming fast!\"\n\n# Inherits from three parents\nclass Duck(Flyer, Swimmer):\n \tpass\n\nduck = Duck()\nprint(duck.fly())\nprint(duck.swim())\n```\n\n---\n\n### 4. Advanced Concepts\n\n#### @property (Getters and Setters)\n\nThe `@property` decorator allows you to define methods that can be accessed like attributes, providing a Pythonic way to implement getter, setter, and deleter logic for validation or computation.\n\n```python\nclass Circle:\n \tdef __init__(self, radius):\n \t\tself._radius = radius\n\n \t@property\n \tdef radius(self): # Getter (read value)\n \t\treturn self._radius\n\n \t@radius.setter\n \tdef radius(self, value): # Setter (write value with validation)\n \t\tif value < 0:\n \t\t\traise ValueError(\"Radius cannot be negative!\")\n \t\tself._radius = value\n\n \t@property\n \tdef area(self): # Computed property\n \t\treturn 3.14 * self._radius ** 2\n\nc = Circle(5)\nprint(f\"Area: {c.area:.2f}\")\nc.radius = 10 # Calls the @radius.setter method\n```\n\n#### Polymorphism\n\n**Polymorphism** means 'many forms.' In OOP, it allows different objects to respond to the same method call (e.g., `speak()`) in their own unique, class-defined way.\n\n```python\n# Dog and Duck objects respond differently to the speak() method\nclass Dog: def speak(self): return \"Woof!\"\nclass Duck: def speak(self): return \"Quack!\"\n\nanimals = [Dog(), Duck()]\nfor animal in animals:\n \tprint(animal.speak())\n```\n\n#### Class Method (`@classmethod`) & Static Method (`@staticmethod`)\n\n| Decorator | Argument | Purpose |\n| :--- | :--- | :--- |\n| **`@classmethod`** | Receives the class itself (`cls`). | Used for constructors or methods that operate on the class state (class variables). |\n| **`@staticmethod`** | No required arguments (no `self` or `cls`). | Utility functions related to the class but not dependent on instance or class state. |\n\n```python\nclass Game:\n \tgame_name = \"Epic Adventure\"\n\n \t@classmethod\n \tdef get_game_name(cls):\n \t\treturn cls.game_name\n\n \t@staticmethod\n \tdef is_valid_username(name):\n \t\treturn len(name) >= 3 and name.isalnum()\n\nprint(Game.get_game_name())\nprint(Game.is_valid_username(\"alex123\"))\n```\n\n---\n\n### 5. Magic Methods (Dunders)\n\n**Magic Methods** (or Dunder methods, for **D**ouble **Under**score) are methods Python calls internally in response to specific operations, allowing you to customize behavior.\n\n| Method | Python Operation |\n| :--- | :--- |\n| `__str__` | `print(object)` or `str(object)` (Human-readable) |\n| `__repr__` | Used for debugging and lists/containers (Unambiguous) |\n| `__len__` | `len(object)` |\n\n```python\nclass Inventory:\n \t# ... (init and add methods omitted)\n\n \tdef __len__(self):\n \t\treturn len(self.items) # Customizes what len() returns\n\ninv = Inventory()\n# ... add items\n# print(len(inv)) # Uses the __len__ method!\n```"
    }
}